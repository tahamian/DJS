\documentclass[12pt, titlepage]{article}
\usepackage{float}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\title{SE 3XA3: Test Plan\\Title of Project}

\author{Team , Team Name
		\\ Student 1 name and macid
		\\ Student 2 name and macid
		\\ Student 3 name and macid
}

\date{\today}



\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}


\section{General Information}

\subsection{Purpose}
The test plan document is a helpful tool for many large scale projects since it allows concise information about testing,verification, and validation geared towards the project. The following test cases were created for future references and allows the project to be implementated with testing and maintenance in mind. The test plan document will be updated before the project is fully implementated to allow for revision and any major changes involved.

\subsection{Scope}
The project, "DJS",is a democratic voting system which allows users to vote for music. Thus testing can cover many areas such as: client methods (ie: update song client, etc), server methods (ie: create Cookie), data structures, and sorting algorithms. 

\subsection{Acronyms, Abbreviations, and Symbols}
	
\begin{table}[hbp]
\caption{\textbf{Table of Abbreviations}} \label{Table}

\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Abbreviation} & \textbf{Definition} \\
\midrule

Abbreviation2 & Definition2\\
\bottomrule
\end{tabularx}

\end{table}

\begin{table}[!htbp]
\caption{\textbf{Table of Definitions}} \label{Table}

\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Term} & \textbf{Definition}\\
\midrule
Term1 & Definition1\\
Term2 & Definition2\\
\bottomrule
\end{tabularx}

\end{table}	

\subsection{Overview of Document}
	This is the test plan document for the project DJS, which is a reconstruction of the application PlayMyWay (href this).
The test plan uses the functional and non-functional requirements to detect any errors in the project DJS.
The document goes over various techniques for testing such as Manual and automated testing, structural and
functional testing, static and dynamic testing, fault testing.

\section{Plan}
	
\subsection{Software Description}
->The project uses nodejs 
-> handle bars 
->player.js for the music player
-> using cookies to store user info
-> uses server.js for the server
\subsection{Test Team}
All project members will participate and be responsible for writing and executing tests.

\subsection{Automated Testing Approach}

\subsection{Testing Tools}
We will be using JSDocs for documentation 

\subsection{Testing Schedule}
->webpage is operational//
->server handles multiple users//
->voting system works//
->Songs queue order is correct//
->
See Gantt Chart at the following url ...

\section{System Test Description}

\subsection{Tests for Functional Requirements}

\subsubsection{Client-side Graphical Interface}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Webpage Title and Buttons Loaded}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & Web page is not loaded.\\

\textbf{Input: } & User's internet browser should navigate to the servers web address.\\

\textbf{Output: } & The server should serve the users request and load a webpage with a title and five buttons underneath.\\

\textbf{Test Procedure:  } &   The web page should be loaded and the title along with 5 buttons should be displayed to the user.\\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Button Includes Song Title}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & Web page is opened on users internet browser.\\

\textbf{Input: } & User's internet browser should navigate to the servers web address.\\

\textbf{Output: } & The webpage loaded should include five buttons with each button having text. The text inside each button should be of a different unique song title (each button has a song title).\\

\textbf{Test Procedure:  } & Load webpage on user internet browser and check if buttons have song titles (if test failed then output should be giberish on button).\\
\hline
\end{tabularx}
\end{table}
\end{center}



\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Vote Causes Button To Be Highlighted}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & Web page is opened on users internet browser and buttons should be present with no prior votes.\\

\textbf{Input: } & User clicks on one button from the webpage.\\

\textbf{Output: } & The corresponding button selected will be highlighted in some form to indicate a vote has been cast and recorded .\\

\textbf{Test Procedure:  } & Load webpage on user internet browser and check if buttons have loaded. Once the buttons are present the tester selects one song and should result in the same button being highlighted.\\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Graphic Object Shows Total Number Of Votes}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & The web address is not loaded. The server has just started.\\

\textbf{Input: } & User navigates to web address.\\

\textbf{Output: } & The web page should load some graphical object which contains the number of votes for each corresponding button. The number of votes should be zero initially .\\

\textbf{Test Procedure:  } & The server should be freshly started. The tester should then navigate to the appropriate web url and load the web page. Once the web page has been loaded the tester can then observe the total number of votes.\\
\hline
\end{tabularx}
\end{table}
\end{center}

\subsubsection{Client-side Backend Interface}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Remeber Voted Song}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & One song should have been voted and the internet browser closed.\\

\textbf{Input: } & The tester will place a vote on one random song and close the browser. After, the web page should be opened again by the tester and the page loaded.\\

\textbf{Output: } & The song title that was picked before closing the internet browser should be highlighted.\\

\textbf{Test Procedure: } & The tester will open a internet browser and load the webpage. After the webpage has been loaded the user will cast a vote. The internet browser opened previously will be closed. Then after the tester will reopen the internet browser and the song title that was selected previously should be highlighted.\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Song List Should Be Valid}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Automated Testing\\

\textbf{Initial State: } & The web address is loaded. The server has just started.\\

\textbf{Input: } & The song titles that appears on website will be the input for the automated testing.Another input would be the music currently available on the server.\\

\textbf{Output: } & The unit testing function will return either with true or false. The result of true will indicate that the song list appeared on the web page matches the song titles available on the server.\\

\textbf{Test Procedure:  } & The automated test will record each song title generated and displayed on the client side. Furthermore, the songs available to the server will also be recorded. The result is calculated by matching all the songs recorded from the web page to the songs available to the server\\
\hline
\end{tabularx}
\end{table}
\end{center}



\subsubsection{Server-side Backend}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Create Cookie To Allow One Vote Per User}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The web address is not loaded. The server has just started.\\

\textbf{Input: } & A simulated user with random voting pattern that is active every couple of seconds.\\

\textbf{Output: } & The unit testing function will return true or false. The testing function will return true when the sum of total votes for each song  equals the number of users connected.Correspondingly the return value of false will suggest that one or more simulated users will have more then one vote.\\

\textbf{Test Procedure:  } & The automated test will create a certain number of random users. The server will create a cookie for each user that indicates a unique id to identify each user. The randomly generated users will all vote for one song that is picked randomly and then change all the votes to another random song ( ie. users 1..15 vote for song 1 then vote for song 2). The test function will then check the number of total votes for each song and sum them together which should equal the number of users generated. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Reset Votes After Playing Song}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The number of total votes for a certain song is above zero.\\

\textbf{Input: } & The test function will need the total number of votes right after a certain song has been done playing.\\

\textbf{Output: } & The unit test function will return true or false. The test function will return true when the total number of votes after playing a song is zero.\\

\textbf{Test Procedure: } & The test procedure will start by having the webpage start with a song with the total number of votes above zero. The test function will then check after the song has played if the total number of votes is equal to zero. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Check If Song List Is Unique}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The server started and web page loaded.\\

\textbf{Input: } & The test function will need the song list that is being sent to the client.\\

\textbf{Output: } & The unit test function will return true if the song list sent is unique and has no duplicates.\\

\textbf{Test Procedure: } &The test function will use the song list being sent to the client and store it into an array. As the song list for the client updates after a song has been played the new song list will be appended to the array. After the last song has played the test function will check the array to see if the server has sent any duplicate song titles and will result in a true or false value. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Check If 5 Random Songs Picked}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The server started and web page loaded.\\

\textbf{Input: } & The test function will need to count the number of songs sent to the client after playing the current song.\\

\textbf{Output: } & The unit testing function will return true if the count is equal to five after playing the current song .\\

\textbf{Test Procedure: } &The test function will use a counter and check if the counter is equal to five after the current song is done being played. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Play Most Voted Song}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The server started and web page loaded.\\

\textbf{Input: } & The test function will need to record the total number of votes and the corresponding song title picked.\\

\textbf{Output: } & The unit testing function will return true if the application plays the right song.\\

\textbf{Test Procedure: } &The testing function will use a counter and rank the songs by votes and check if the playing is song is equal to the song selected with the most votes. \\
\hline
\end{tabularx}
\end{table}
\end{center}




\subsection{Tests for Nonfunctional Requirements}

\subsubsection{Look and Feel Requirements}
		
\paragraph{Title for Test}

\begin{enumerate}

\item{test-id1\\}

Type: 
					
Initial State: 
					
Input/Condition: 
					
Output/Result: 
					
How test will be performed: 
					
\item{test-id2\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 

\end{enumerate}

\subsubsection{Area of Testing2}

...

\section{Tests for Proof of Concept}

\subsection{KO}
		
\paragraph{Test for Visual Items}

\begin{enumerate}

\item{test-id1\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 
					
\item{test-id2\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 

\end{enumerate}

\subsection{Area of Testing2}

...

	
\section{Comparison to Existing Implementation}	
The product DJS is a dynamic voting system which allows user to vote for certain songs. The previously implemented open source project called PlayMyWay lacked in well documented code. Comparing the two products is beneficial to DJS since it allows the product to evolve. The changes that might occur however are dependent on the project's progress and would require the scope to change. The modification to the scope would help develop and implement core features in DJS. The requirements that may add extra features will only be incorporated if time permits. The subsection of requirements such as look and feel, performance, security, and accuracy still need improvements. The section for look and feel for example is only partially implemented in the proof of concept. The requirement of displaying the total number of votes for each song will only be added if time permits. Another example, the performance requirement of loading buttons and quickly is still waiting to be implemented.  However, since most core requirements such as playing music and voting have been fulfilled most requirements suggested from before and others will be developed. Although most requirements are important  the list may also be narrowed down to help create more time for more ideal requirements such as total votes. Thus, after comparing DJS with the original implementation it demonstrates the similarities and the small differences still left to be negated  

				
\section{Unit Testing Plan}
		
\subsection{Unit testing of internal functions}
		
\subsection{Unit testing of output files}		

\bibliographystyle{plainnat}

\bibliography{SRS}

\newpage

\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions?}

This is a section that would be appropriate for some teams.

\end{document}
