\documentclass[12pt, titlepage]{article}
\usepackage{float}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{color}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\title{SE 3XA3: Test Plan\\DJS}

\author{Team 12 , DJS
		\\ Amandeep Panesar panesas2
		\\ Taha Mian miantm
		\\ Victor velechva
}

\date{\today}

\begin{document}

\newcommand{\acceptableRating}{\textcolor{blue}{7.5 }}
\newcommand{\numberOfSongs}{\textcolor{blue}{5 }}
\newcommand{\numberOfStressTestClients}{\textcolor{blue}{300 }}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
OCT 28 & 0.1 & Rev0\\
DEC 6 & 1.0 & Rev1\\

\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

\section{General Information}

\subsection{Purpose}
The test plan document is a helpful tool for many large scale projects since it allows concise information about testing,verification, and validation geared towards the project. The following test cases were created for future references and allows the project to be implementated with testing and maintenance in mind. The test plan document will be updated before the project is fully implementated to allow for revision and any major changes involved.

\subsection{Scope}
The project, "DJS",is a democratic voting system which allows users to vote for music. Thus testing can cover many areas such as: client methods (ie: update song client, etc), server methods (ie: create Cookie), data structures, and sorting algorithms.

\subsection{Acronyms, Abbreviations, and Symbols}

\subsection{Overview of Document}
\textcolor{red}{Making an issue to href something MAY be a better idea - CM} \\
This is the test plan document for the project DJS, which is a reconstruction of the application PlayMyWay: \url{https://github.com/malithsen/playmyway}.
The test plan uses the functional and non-functional requirements to detect any errors in the project DJS.
The document goes over various techniques for testing such as Manual and automated testing, structural and
functional testing, static and dynamic testing, fault testing.

\section{Plan}

\subsection{Software Description}
The server running DJS is using nodejs with multiple libraries which includes : express,
handlebars, express--handlebars, and socket.io.
\textcolor{blue}{The server running DJS is using node.js with multiple libraries which
consist of the following: express, handlebars, express--handlebars, and socket.io.
The implementation of DJS has been made into eight modules. The module server.js is used
for hosting the webpage and uses several modules such as, voter.js, player.js, metadata.js,
home.js, library.js, args.js, and error-handler.js. However, server.js is the main module
that is being used in every other module. Server.js uses library.js to get an N amount of
songs, the number N is set in the module server.js, and in this case the number has been
pre-set to \numberOfSongs. The function of library.js is to get a list of songs that are to be displayed
on the webpage to be voted for and the songs are then randomly selected. The same idea can
be applied to metadata.js, except metadata.js gets the metadata of the songs selected by
library.js and saves the album in a folder called artwork. Another module, voter.js also
relies on server.js because voter.js counts the amount of votes and server.js selects the
song with the highest amount of votes. Furthermore, home.js is used to display the webpage
by server.js this consists of all the information such as artwork, title of the song, and
number of votes. Also, server.js uses player.js to just play audio to the speakers of the
system. Moreover, error-handler.js is used by server.js for catching errors and determines
what message to print to the terminal. Lastly, args.js is used by server.js when the user
runs server.js with certain command line arguments.
}

\subsection{Test Team}
All project members will participate and be responsible for writing and executing tests.

\subsection{Automated Testing Approach}
\textcolor{red}{Speak to the why, where and how you will run automatic tests - CM} \\

\textcolor{blue}{
Automated testing will be done through white-box unit tests and system-wide black-box tests.
White-box unit testing will be used to test the output of various functions in the server,
 library, player, metadata, args, and error-handler modules.
White-box system-wide testing will be done to ensure that the system fulfills the more
broad functional requirements, and that the server and client are able to work
together correctly. The testing suite will automatically connect to the server with a
web browser instance, vote for songs, and check that the resulting webpage data is correct.
}

\subsection{Testing Tools}
\textcolor{red}{Should the reader know these? What are they for, purpose? I know Karma includes many features, which will you use? - CM} \\

\textcolor{blue}{
Unit testing will be done with Mocha.JS, a unit testing
library for Node.JS and Javascript.
System testing will be done with Selenium-Webdriver, a library that simulates a web browser, connects to the server,
simulates user interaction, and gathers information about the resulting webpage, to determine
 proper functionality. Specifically, the Webdriver will connect to the server, and determine
 if the UI elements display songs, with clickable buttons, album art, and a vote count that
 is initially zero. The webdriver will cast a vote for the first song, and see if the
 vote-count reflects this by incrementing from 0 to 1.
}

\subsection{Testing Schedule}
\textcolor{red}{Poor formatting, poor use of Gantt charts - CM} \\
\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{ c | c }
\textcolor{blue}{Functionality Being Tested} & \textcolor{blue}{To Be Completed by:} \\
\hline
\textcolor{blue}{Webpage should be operational} & \textcolor{blue}{Oct 21/16} \\
\textcolor{blue}{Webpage loads the right metadata and song title} & \textcolor{blue}{Oct 22/16} \\
\textcolor{blue}{Voting system counts the right amount of votes} & \textcolor{blue}{Oct 23/16} \\
\textcolor{blue}{Voting sytem selects the right song} & \textcolor{blue}{Oct 23/16} \\
\textcolor{blue}{Songs in queue} & \textcolor{blue}{Oct 25/16} \\
\textcolor{blue}{Server should be able to handle multiple users} & \textcolor{blue}{Oct 28/16} \\
\end{tabularx}
\end{table}
\end{center}

\textcolor{green}{This can also be found in the} \href{run:d:/ProjectSchedule/DJSGanttChart.gan}{Gnatt Chart here}.

\section{System Test Description}

\subsection{Tests for Functional Requirements}

\subsubsection{Client-side Graphical Interface}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Webpage Title and Buttons Loaded}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & Web page is not loaded.\\

\textbf{Input: } & User's internet browser should navigate to the servers web address.\\

\textbf{Output: } & The server should serve the users request and load a webpage with a title and five buttons underneath.\\

\textbf{Test Procedure:  } &   The web page should be loaded and the title along with \numberOfSongs buttons should be displayed to the user.\\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Button Includes Song Title}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & Web page is opened on users internet browser.\\

\textbf{Input: } & User's internet browser should navigate to the servers web address.\\

\textbf{Output: } & The webpage loaded should include five buttons with each button having text. The text inside each button should be of a different unique song title (each button has a song title).\\

\textbf{Test Procedure:  } & Load webpage on user internet browser and check if buttons have song titles (if test failed then output should be giberish on button).\\
\hline
\end{tabularx}
\end{table}
\end{center}



\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Vote Causes Button To Be Highlighted}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & Web page is opened on users internet browser and buttons should be present with no prior votes.\\

\textbf{Input: } & User clicks on one button from the webpage.\\

\textbf{Output: } & The corresponding button selected will be highlighted in some form to indicate a vote has been cast and recorded .\\

\textbf{Test Procedure:  } & Load webpage on user internet browser and check if buttons have loaded. Once the buttons are present the tester selects one song and should result in the same button being highlighted.\\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Graphic Object Shows Total Number Of Votes}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & The web address is not loaded. The server has just started.\\

\textbf{Input: } & User navigates to web address.\\

\textbf{Output: } & The web page should load some graphical object which contains the number of votes for each corresponding button. The number of votes should be zero initially .\\

\textbf{Test Procedure:  } & The server should be freshly started. The tester should then navigate to the appropriate web url and load the web page. Once the web page has been loaded the tester can then observe the total number of votes.\\
\hline
\end{tabularx}
\end{table}
\end{center}

\subsubsection{Client-side Backend Interface}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Remeber Voted Song}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\

\textbf{Initial State: } & One song should have been voted and the internet browser closed.\\

\textbf{Input: } & The tester will place a vote on one random song and close the browser. After, the web page should be opened again by the tester and the page loaded.\\

\textbf{Output: } & The song title that was picked before closing the internet browser should be highlighted.\\

\textbf{Test Procedure: } & The tester will open a internet browser and load the webpage. After the webpage has been loaded the user will cast a vote. The internet browser opened previously will be closed. Then after the tester will reopen the internet browser and the song title that was selected previously should be highlighted.\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Song List Should Be Valid}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Automated Testing\\

\textbf{Initial State: } & The web address is loaded. The server has just started.\\

\textbf{Input: } & The song titles that appears on website will be the input for the automated testing.Another input would be the music currently available on the server.\\

\textbf{Output: } & The unit testing function will return either with true or false. The result of true will indicate that the song list appeared on the web page matches the song titles available on the server.\\

\textbf{Test Procedure:  } & The automated test will record each song title generated and displayed on the client side. Furthermore, the songs available to the server will also be recorded. The result is calculated by matching all the songs recorded from the web page to the songs available to the server\\
\hline
\end{tabularx}
\end{table}
\end{center}



\subsubsection{Server-side Backend}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Create Cookie To Allow One Vote Per User}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The web address is not loaded. The server has just started.\\

\textbf{Input: } & A simulated user with random voting pattern that is active every couple of seconds.\\

\textbf{Output: } & The unit testing function will return true or false. The testing function will return true when the sum of total votes for each song  equals the number of users connected.Correspondingly the return value of false will suggest that one or more simulated users will have more then one vote.\\

\textbf{Test Procedure:  } & The automated test will create a certain number of random users. The server will create a cookie for each user that indicates a unique id to identify each user. The randomly generated users will all vote for one song that is picked randomly and then change all the votes to another random song ( ie. users 1..15 vote for song 1 then vote for song 2). The test function will then check the number of total votes for each song and sum them together which should equal the number of users generated. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Reset Votes After Playing Song}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The number of total votes for a certain song is above zero.\\

\textbf{Input: } & The test function will need the total number of votes right after a certain song has been done playing.\\

\textbf{Output: } & The unit test function will return true or false. The test function will return true when the total number of votes after playing a song is zero.\\

\textbf{Test Procedure: } & The test procedure will start by having the webpage start with a song with the total number of votes above zero. The test function will then check after the song has played if the total number of votes is equal to zero. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Check If Song List Is Unique}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The server started and web page loaded.\\

\textbf{Input: } & The test function will need the song list that is being sent to the client.\\

\textbf{Output: } & The unit test function will return true if the song list sent is unique and has no duplicates.\\

\textbf{Test Procedure: } &The test function will use the song list being sent to the client and store it into an array. As the song list for the client updates after a song has been played the new song list will be appended to the array. After the last song has played the test function will check the array to see if the server has sent any duplicate song titles and will result in a true or false value. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Check If \numberOfSongs Random Songs Picked}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The server started and web page loaded.\\

\textbf{Input: } & The test function will need to count the number of songs sent to the client after playing the current song.\\

\textbf{Output: } & The unit testing function will return true if the count is equal to five after playing the current song .\\

\textbf{Test Procedure: } &The test function will use a counter and check if the counter is equal to five after the current song is done being played. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Play Most Voted Song}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\

\textbf{Initial State: } & The server started and web page loaded.\\

\textbf{Input: } & The test function will need to record the total number of votes and the corresponding song title picked.\\

\textbf{Output: } & The unit testing function will return true if the application plays the right song.\\

\textbf{Test Procedure: } &The testing function will use a counter and rank the songs by votes and check if the playing is song is equal to the song selected with the most votes. \\
\hline
\end{tabularx}
\end{table}
\end{center}


\subsection{Tests for Nonfunctional Requirements}
\textcolor{red}{ I don't like how these are structured. For example, NF Test 1: Initial State: Webpage has not been loaded. Input: User opens the webpage by doing X. Output: Webpage is open. How Test is Preformed: The user will rate on a scale... That is a better test because it is specific and repeatable. Also, make a survey and use symbolic parameters for everything (e.g. stress testing)  - CM} \\
\subsubsection{Look and Feel Requirements}

\paragraph{Appearance Tests}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{User Interface is aesthetically pleasing}}}\\
\hline
\textbf{Type: } & Structural, Static, Manual\\
\textbf{Initial State: } & At least 20 users take a feedback survey\\
\textbf{Input: } & User rates web page based on the aesthetics (from 1 to 10) on a custom survey\\
\textbf{Output: } & Average results of survey \\
\textbf{Test Procedure:  } & At least 20 users will take a short survey rating the appearance. The results will be tabulated and an average calculated. The average must be atleast \acceptableRating \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Style Tests}


\subsubsection{Usability and Humanity Requirements}

\paragraph{Ease of Use Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{User Interface is easy to use}}}\\
\hline
\textbf{Type: } & Structural, Static, Manual\\
\textbf{Initial State: } & At least 20 users take a feedback survey\\
\textbf{Input: } & User rates web page based on the ease of use (from 1 to 10) on a custom survey\\
\textbf{Output: } & Average results of survey \\
\textbf{Test Procedure:  } & At least 20 users will take a short survey rating the appearance The results will be tabulated and an average calculated. The average must be atleast \acceptableRating \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Understandability and Politeness Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{User Help Manual is helpful and understandable}}}\\
\hline
\textbf{Type: } & Structural, Static, Manual\\
\textbf{Initial State: } & At least 20 users take a feedback survey\\
\textbf{Input: } & User rates the effectiveness of the survey\\
\textbf{Output: } & Average results of survey \\
\textbf{Test Procedure:  } & At least 20 users will take a short survey rating the appearance The results will be tabulated and an average calculated. The average must be atleast \acceptableRating \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Accessibility Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Web page is loadable on a local WiFi connection}}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & User attempts to connect to server hosted on the same WiFi network\\
\textbf{Input: } & N/A\\
\textbf{Output: } & The web page is loaded on the device from local WiFi \\
\textbf{Test Procedure:  } & The web page will be loaded from five different devices on two local Wireless networks. All devices should connect and display the webpage \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Web page functions on all HTML5 web browsers}}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & User attempts to connect to server hosted on the same WiFi network\\
\textbf{Input: } & N/A\\
\textbf{Output: } & The web page is loaded on the device from local WiFi \\
\textbf{Test Procedure:  } & The web page will be loaded on at least 5 different browsers (all of which support HTML5). The voting mechanism should be functional on all devices \\
\hline
\end{tabularx}
\end{table}
\end{center}

\subsubsection{Performance Requirements}

\paragraph{Speed and Latency Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Web page must load within 3 seconds}}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Manual\\
\textbf{Initial State: } & Web page is loaded from a device connected to the same WiFi network. The server must be running on an x86-54 based, OS X or Linux system\\
\textbf{Input: } & N/A\\
\textbf{Output: } & N/A \\
\textbf{Test Procedure:  } & It should take no longer than three seconds for the web page to load and cast a vote \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Precision Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Song with most votes is always selected to play next}}}\\
\hline
\textbf{Type: } & Structural, Manual, Automated\\
\textbf{Initial State: } & Server is running, users are connected\\
\textbf{Input: } & User Votes are inputted to the voter module\\
\textbf{Output: } & Vote choice is determined and returned by the voter module \\
\textbf{Test Procedure:  } & The highest voted song (or any of the highest rated, in the case of a tie for first place) should be selected. Automated testing done in test-voter module \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Reliability and Availability Requirement Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Server should constantly be playing music}}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & Server is not running\\
\textbf{Input: } & Start the server\\
\textbf{Output: } & Audio output to speakers \\
\textbf{Test Procedure:  } & Music should begin playing initially, and continue to play without any user interaction until all music in music directory have been played \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Robustness Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Server handles songs with empty album art metadata}}}\\
\hline
\textbf{Type: } & Structural, Automated/Manual, Static\\
\textbf{Initial State: } & Server is running\\
\textbf{Input: } & Songs with empty metadata are in the music folder\\
\textbf{Output: } & Data sent to webpage \\
\textbf{Test Procedure:  } & Songs with no album artwork should not crash the system, and should display a 'default' album art picture on the webpage. Automated testing is done in the test-metadata module \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Capacity Requirements Test}

\paragraph{Scalability Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Server should handle at least \numberOfStressTestClients users at a time}}}\\
\hline
\textbf{Type: } & Structural, Automated, Static\\
\textbf{Initial State: } & Server is running\\
\textbf{Input: } & \numberOfStressTestClients clients, generated by selenium-webdriver, connect to the server\\
\textbf{Output: } & N/A \\
\textbf{Test Procedure:  } & Server performance should not be significantly affected. Voting and music playback should still function \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Longevity Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Server should continue to run unless manually turned off}}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & Server is not running\\
\textbf{Input: } & Run the server\\
\textbf{Output: } & N/A \\
\textbf{Test Procedure:  } & Server should run continuously for at least 20 minutes without user interaction, then terminated by the user \\
\hline
\end{tabularx}
\end{table}
\end{center}

\subsubsection{Operational and Environmental Requirements}

\paragraph{Requirements for Interfacing with Adjacent Systems Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Web page functions on all HTML5 web browsers}}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & User attempts to connect to server hosted on the same WiFi network\\
\textbf{Input: } & N/A\\
\textbf{Output: } & The web page is loaded on the device from local WiFi \\
\textbf{Test Procedure:  } & The web page will be loaded on at least 5 different browsers (all of which support HTML5). The voting mechanism should be functional on all devices \\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Productization Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Server is installable on Mac OS and Linux through the given terminal commands}}}\\
\hline
\textbf{Type: } & Static, Manual, Structural\\
\textbf{Initial State: } & Mac OS machine without the server installed\\
\textbf{Input: } & Server is installed via the install command given in the README\\
\textbf{Output: } & Server is functional \\
\textbf{Test Procedure:  } & All other test requirements should be passed on this system \\
\hline
\end{tabularx}
\end{table}
\end{center}

\subsubsection{Maintainability and Support Requirements}

\paragraph{Access Requirements Test}

\paragraph{Privacy Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Restarting the device or browser should not allow voting twice}}}\\
\hline
\textbf{Type: } & Structural, Manual, Dynamic\\
\textbf{Initial State: } & Web page is loaded from a device on a local network. A vote is issued, then the device is restarted and reconnected\\
\textbf{Input: } & N/A\\
\textbf{Output: } & N/A \\
\textbf{Test Procedure:  } & The second vote should replace the initial vote on the server \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Webpage is only accessible from a local network}}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & Attempt to load web page from outside the local network\\
\textbf{Input: } & N/A\\
\textbf{Output: } & HTML response \\
\textbf{Test Procedure:  } & The server should not be accessible from an outside network \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{\textcolor{blue}{Users should have no access to other user data}}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & Connect to server\\
\textbf{Input: } & N/A\\
\textbf{Output: } & HTML Response \\
\textbf{Test Procedure:  } & The HTML response should contain no data about other users, other than how many votes have been totalled for each song \\
\hline
\end{tabularx}
\end{table}
\end{center}

\section{Tests for Proof of Concept}



\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Run Server}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Manual Testing\\

\textbf{Initial State: } & Nothing Running .\\

\textbf{Input: } & Javascript Files.\\

\textbf{Output: } & Running Server.\\

\textbf{Test Procedure: } & The server should run when the command node file.js is ran. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Play Music}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Manual Testing\\

\textbf{Initial State: } & Server should be running and no music should be played .\\

\textbf{Input: } & Any song from the generated song list.\\

\textbf{Output: } & Music playing.\\

\textbf{Test Procedure: } & Run server and vote for any song. Then after votes have been counted the song with the most votes should be played. \\
\hline
\end{tabularx}
\end{table}
\end{center}
\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Load Buttons}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Manual Testing\\

\textbf{Initial State: } & Nothing Running .\\

\textbf{Input: } & Javascript Files.\\

\textbf{Output: } & Running Server.\\

\textbf{Test Procedure: } & The server should run when the command node file.js is ran. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Voting System}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Manual Testing\\

\textbf{Initial State: } & The server should be running with the webpage loaded with no votes .\\

\textbf{Input: } & Vote .\\

\textbf{Output: } & Vote for song title .\\

\textbf{Test Procedure: } & The server should out put an array for now which shows the votes in a string array. \\
\hline
\end{tabularx}
\end{table}
\end{center}

\section{Comparison to Existing Implementation}
\textcolor{red}{This is NOT just comparing the projects. It is detailing how to parallel test the two to be sure your project matches the other's (and subsequently your) requirements - CM} \\

\textcolor{blue}{
It is not possible to parallel test with the currently existing implementation. PlayMyWay, the project which we based ours on, does not have any automated testing suite, and is not currently in working form. The software is buggy and the server does not satisfy any of the main functional requirements in its current form, due to the software bugs, making a direct comparison impossible.
}

\section{Unit Testing Plan}

\subsection{Unit testing of internal functions}
The implemented unit tests will help examine the product and will allow for clarity. The automated tests will be used to test a multitude of functional and nonfunctional requirements.  Majority of these tests will use the internal functions and variables implemented in the product. All tests will be correlated to core functions utilized in the product to ensure predictable outputs and behaviours for normal, abnormal, and negative scenarios.

\subsection{Unit testing of output files}
The output for the DJS product will be the music playing and the client-side graphical interface. The unit testing for output will be done with the combination of both manual and automated testing. In addition, the testing of output will also include using an external library called selenium which helps javascript simulate clicks and other actions a user would commit. The tests will call functions that create the view and check if the view has appeared. An example would be is checking if the buttons have been loaded. The test for checking if buttons have appeared would involved the selenium library and would simulate buttons clicks. The unit tests will ensure that the proper methods are called and the output is the expected result.
\bibliographystyle{plainnat}

\bibliography{SRS}

\newpage

\end{document}
