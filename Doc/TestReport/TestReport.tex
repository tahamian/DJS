\documentclass[12pt, titlepage]{article}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{float}
\usepackage{color}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}
\newcommand{\acceptableRating}{\textcolor{blue}{7.5 }}
\newcommand{\numberOfSongs}{\textcolor{blue}{5 }}
\newcommand{\numberOfStressTestClients}{\textcolor{blue}{300 }}

\title{SE 3XA3: Test Report\\DJS}

\author{Team , Team Name
		\\ Student 1 name and macid
		\\ Student 2 name and macid
		\\ Student 3 name and macid
}

\date{\today}


\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[H]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

\section{Introduction}

This document outlines a report on the various tests that were conducted to verify the functionality of DJS. Test cases can be performed by interest clients to determine the validity of our software, and the robustness of our test suite.

\section{Functional Requirements Evaluation}
Testing was performed with white box unit testing, black box automated system testing, black box manual system testing, and stress testing.\\


Due to the nature of a server/client system, it is difficult to provide a complete test suite to ensure complete functionality of the system. However, an adequate test suite was provided. \\


All functional tests passed.


\subsection{Client-side Graphical Interface}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Webpage Title and Buttons Loaded}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\


\textbf{Initial State: } & Web page is not loaded.\\


\textbf{Input: } & User's internet browser should navigate to the servers web address.\\


\textbf{Output: } & The server should serve the users request and load a webpage with a title and five buttons underneath.\\


\textbf{Test Procedure:  } &   The web page should be loaded and the title along with \numberOfSongs buttons should be displayed to the user.\\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Button Includes Song Title}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\


\textbf{Initial State: } & Web page is opened on users internet browser.\\


\textbf{Input: } & User's internet browser should navigate to the servers web address.\\


\textbf{Output: } & The webpage loaded should include five buttons with each button having text. The text inside each button should be of a different unique song title (each button has a song title).\\


\textbf{Test Procedure:  } & Load webpage on user internet browser and check if buttons have song titles (if test failed then output should be giberish on button).\\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}






\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Vote Causes Button To Be Highlighted}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\


\textbf{Initial State: } & Web page is opened on users internet browser and buttons should be present with no prior votes.\\


\textbf{Input: } & User clicks on one button from the webpage.\\


\textbf{Output: } & The corresponding button selected will be highlighted in some form to indicate a vote has been cast and recorded .\\


\textbf{Test Procedure:  } & Load webpage on user internet browser and check if buttons have loaded. Once the buttons are present the tester selects one song and should result in the same button being highlighted.\\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Graphic Object Shows Total Number Of Votes}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\


\textbf{Initial State: } & The web address is not loaded. The server has just started.\\


\textbf{Input: } & User navigates to web address.\\


\textbf{Output: } & The web page should load some graphical object which contains the number of votes for each corresponding button. The number of votes should be zero initially .\\


\textbf{Test Procedure:  } & The server should be freshly started. The tester should then navigate to the appropriate web url and load the web page. Once the web page has been loaded the tester can then observe the total number of votes.\\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}


\subsection{Client-side Backend Interface}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Remeber Voted Song}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Manual Testing\\


\textbf{Initial State: } & One song should have been voted and the internet browser closed.\\


\textbf{Input: } & The tester will place a vote on one random song and close the browser. After, the web page should be opened again by the tester and the page loaded.\\


\textbf{Output: } & The song title that was picked before closing the internet browser should be highlighted.\\


\textbf{Test Procedure: } & The tester will open a internet browser and load the webpage. After the webpage has been loaded the user will cast a vote. The internet browser opened previously will be closed. Then after the tester will reopen the internet browser and the song title that was selected previously should be highlighted.\\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}




\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Song List Should Be Valid}}\\
\hline
\textbf{Type: } & Functional, Dynamic, Automated Testing\\


\textbf{Initial State: } & The web address is loaded. The server has just started.\\


\textbf{Input: } & The song titles that appears on website will be the input for the automated testing.Another input would be the music currently available on the server.\\


\textbf{Output: } & The unit testing function will return either with true or false. The result of true will indicate that the song list appeared on the web page matches the song titles available on the server.\\


\textbf{Test Procedure:  } & The automated test will record each song title generated and displayed on the client side. Furthermore, the songs available to the server will also be recorded. The result is calculated by matching all the songs recorded from the web page to the songs available to the server\\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\subsection{Server-side Backend}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Create Cookie To Allow One Vote Per User}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\


\textbf{Initial State: } & The web address is not loaded. The server has just started.\\


\textbf{Input: } & A simulated user with random voting pattern that is active every couple of seconds.\\


\textbf{Output: } & The unit testing function will return true or false. The testing function will return true when the sum of total votes for each song  equals the number of users connected.Correspondingly the return value of false will suggest that one or more simulated users will have more then one vote.\\


\textbf{Test Procedure:  } & The automated test will create a certain number of random users. The server will create a cookie for each user that indicates a unique id to identify each user. The randomly generated users will all vote for one song that is picked randomly and then change all the votes to another random song ( ie. users 1..15 vote for song 1 then vote for song 2). The test function will then check the number of total votes for each song and sum them together which should equal the number of users generated. \\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Reset Votes After Playing Song}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\


\textbf{Initial State: } & The number of total votes for a certain song is above zero.\\


\textbf{Input: } & The test function will need the total number of votes right after a certain song has been done playing.\\


\textbf{Output: } & The unit test function will return true or false. The test function will return true when the total number of votes after playing a song is zero.\\


\textbf{Test Procedure: } & The test procedure will start by having the webpage start with a song with the total number of votes above zero. The test function will then check after the song has played if the total number of votes is equal to zero. \\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Check If Song List Is Unique}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\


\textbf{Initial State: } & The server started and web page loaded.\\


\textbf{Input: } & The test function will need the song list that is being sent to the client.\\


\textbf{Output: } & The unit test function will return true if the song list sent is unique and has no duplicates.\\


\textbf{Test Procedure: } &The test function will use the song list being sent to the client and store it into an array. As the song list for the client updates after a song has been played the new song list will be appended to the array. After the last song has played the test function will check the array to see if the server has sent any duplicate song titles and will result in a true or false value. \\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Check If \numberOfSongs Random Songs Picked}}\\

\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\


\textbf{Initial State: } & The server started and web page loaded.\\


\textbf{Input: } & The test function will need to count the number of songs sent to the client after playing the current song.\\


\textbf{Output: } & The unit testing function will return true if the count is equal to five after playing the current song .\\


\textbf{Test Procedure: } &The test function will use a counter and check if the counter is equal to five after the current song is done being played. \\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Play Most Voted Song}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Automated Testing\\


\textbf{Initial State: } & The server started and web page loaded.\\


\textbf{Input: } & The test function will need to record the total number of votes and the corresponding song title picked.\\


\textbf{Output: } & The unit testing function will return true if the application plays the right song.\\


\textbf{Test Procedure: } &The testing function will use a counter and rank the songs by votes and check if the playing is song is equal to the song selected with the most votes. \\


\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\subsection{Automated Testing}

Automated testing was done with a combination of Mocha.JS, a unit testing framework Node.JS, and Selenium-Webdriver. The test cases are located in the test folder, located \href{https://gitlab.cas.mcmaster.ca/velechva/DJS/tree/master/src/test}{here}. 



\section{Nonfunctional Requirements Evaluation}
\subsection{Look and Feel Requirements}

\paragraph{Appearance Tests}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{User Interface is aesthetically pleasing}}\\
\hline
\textbf{Type: } & Structural, Static, Manual\\
\textbf{Initial State: } & At least 20 users take a feedback survey\\
\textbf{Input: } & User rates web page based on the aesthetics (from 1 to 10) on a custom survey\\
\textbf{Output: } & Average results of survey \\
\textbf{Actual Result:  } & The average result of 22 survey respones was 7.7 which is higher than \acceptableRating. Graph can be \href{run:./NFR1.PNG}{found here.} \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Style Tests}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{User Interface is aesthetically pleasing}} \\
\hline
\textbf{Type: } & Structural, Manual, Static etc. \\
\textbf{Initial State: } & Web page is loaded from a device that has Internet \\
\textbf{Input: } &  Users rate the web page on the ascetics of from a rating of one to 10. \\
\textbf{Output: } &  The overall average of the results should be over \acceptableRating. \\
\textbf{Actual Result: } &  The average result of 22 survey respones was 7.6 which is higher than \acceptableRating. Graph can be \href{run:./NFR2.PNG}{found here.} \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline

\end{tabularx}
\end{table}
\end{center}


\subsection{Usability and Humanity Requirements}

\paragraph{Ease of Use Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{User Interface is easy to use}}\\
\hline
\textbf{Type: } & Structural, Static, Manual\\
\textbf{Initial State: } & At least 20 users take a feedback survey\\
\textbf{Input: } & User rates web page based on the ease of use (from 1 to 10) on a custom survey\\
\textbf{Output: } & Average results of survey \\
\textbf{Actual Result:  } &  The average result of 22 survey respones was 7.9 which is higher than \acceptableRating. Graph can be \href{run:./NFR.PNG}{found here.} \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Understandability and Politeness Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{User Help Manual is helpful and understandable}}\\
\hline
\textbf{Type: } & Structural, Static, Manual\\
\textbf{Initial State: } & At least 20 users take a feedback survey\\
\textbf{Input: } & User rates the effectiveness of the survey\\
\textbf{Output: } & Average results of survey \\
\textbf{Actual Result:  } &  The average result of 22 survey respones was 7.6 which is higher than \acceptableRating. Graph can be \href{run:./NFR4.PNG}{found here} \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Accessibility Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Web page is loadable on a local WiFi connection}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & User attempts to connect to server hosted on the same WiFi network\\
\textbf{Input: } & N/A\\
\textbf{Output: } & The web page is loaded on the device from local WiFi \\
\textbf{Actual Result:  } & The Webpage was loaded \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Web page functions on all HTML5 web browsers}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & User attempts to connect to server hosted on the same WiFi network\\
\textbf{Input: } & N/A\\
\textbf{Output: } & The web page is loaded on the device from local WiFi \\
\textbf{Actual Result:  } & The weboage was loaded \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline

\end{tabularx}
\end{table}
\end{center}

\subsection{Performance Requirements}

\paragraph{Speed and Latency Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Web page must load within 3 seconds}}\\
\hline
\textbf{Type: } & Structural, Dynamic, Manual\\
\textbf{Initial State: } & Web page is loaded from a device connected to the same WiFi network. The server must be running on an x86-54 based, OS X or Linux system\\
\textbf{Input: } & N/A\\
\textbf{Output: } & N/A \\
\textbf{Actual Result:  } & Webpage loaded within 3 seconds \\
\textbf{Result: } & \textcolor{green}{PASS}\\

\hline

\end{tabularx}
\end{table}
\end{center}

\paragraph{Precision Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Song with most votes is always selected to play next}}\\
\hline
\textbf{Type: } & Structural, Manual, Automated\\
\textbf{Initial State: } & Server is running, users are connected\\
\textbf{Input: } & User Votes are inputted to the voter module\\
\textbf{Output: } & Vote choice is determined and returned by the voter module \\
\textbf{Actual Result:  } & Voter choice determined and returned \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Reliability and Availability Requirement Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Server should constantly be playing music}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & Server is not running\\
\textbf{Input: } & Start the server\\
\textbf{Output: } & Audio output to speakers \\
\textbf{Actual Result:  } & Audio was being output to speakers \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Robustness Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Server handles songs with empty album art metadata}}\\
\hline
\textbf{Type: } & Structural, Automated/Manual, Static\\
\textbf{Initial State: } & Server is running\\
\textbf{Input: } & Songs with empty metadata are in the music folder\\
\textbf{Output: } & Data sent to webpage \\
\textbf{Actual Result:  } & Webpage was correctly loaded \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}


\paragraph{Scalability Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Server should handle at least \numberOfStressTestClients users at a time}}\\
\hline
\textbf{Type: } & Structural, Automated, Static\\
\textbf{Initial State: } & Server is running\\
\textbf{Input: } & \numberOfStressTestClients clients, generated by selenium-webdriver, connect to the server\\
\textbf{Output: } & N/A \\
\textbf{Actual Result:  } & Server still running correctly \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\paragraph{Longevity Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Server should continue to run unless manually turned off}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & Server is not running\\
\textbf{Input: } & Run the server\\
\textbf{Output: } & N/A \\
\textbf{Actual Result:  } & Server ran, and was terminated by the user \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\subsection{Operational and Environmental Requirements}

\paragraph{Requirements for Interfacing with Adjacent Systems Test}
\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Web page functions on all HTML5 web browsers}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & User attempts to connect to server hosted on the same WiFi network\\
\textbf{Input: } & N/A\\
\textbf{Output: } & The web page is loaded on the device from local WiFi \\
\textbf{Actual Result:  } & Webpage was loaded \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}
\paragraph{Productization Requirements Test}

\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Server is installable on Mac OS and Linux through the given terminal commands}}\\
\hline
\textbf{Type: } & Static, Manual, Structural\\
\textbf{Initial State: } & Mac OS machine without the server installed\\
\textbf{Input: } & Server is installed via the install command given in the README\\
\textbf{Output: } & Server is functional \\
\textbf{Actual Result:  } & Sever properly, all tests passed \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}

\subsection{Maintainability and Support Requirements}

\paragraph{Privacy Requirements Test}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf {Restarting the device or browser should not allow voting twice}}\\
\hline
\textbf{Type: } & Structural, Manual, Dynamic\\
\textbf{Initial State: } & Web page is loaded from a device on a local network. A vote is issued, then the device is restarted and reconnected\\
\textbf{Input: } & N/A\\
\textbf{Output: } & N/A \\
\textbf{Actual Result:  } & Vote was replaced, total votes the same amount \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Webpage is only accessible from a local network}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & Attempt to load web page from outside the local network\\
\textbf{Input: } & N/A\\
\textbf{Output: } & HTML response \\
\textbf{Actual Result:  } & Sever unaccessiable \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Users should have no access to other user data}}\\
\hline
\textbf{Type: } & Structural, Manual, Static\\
\textbf{Initial State: } & Connect to server\\
\textbf{Input: } & N/A\\
\textbf{Output: } & HTML Response \\
\textbf{Actual Result:  } & Only user data was contianed \\
\textbf{Result: } & \textcolor{green}{PASS}\\
\hline
\end{tabularx}
\end{table}
\end{center}

\section{Comparison to Existing Implementation}	
The existing implementation (PlayMyWay) does not have a test suite. The software is currently in a broken state, so a direct comparison was strictly impossible.\\

We were able to analyze the User Interface from screenshots on the Github repo. The interface did not appear as appealing or intuitive as ours. Their app has font the runs off screen in a way that appears very unprofessional. In comparison, our app has word-wrap for long file names.\\

\section{Unit Testing}
The specific modules used for Unit testing can be found in the test folder which is in the src folder. The results for these tests can also be found in the same folder \href{run:../../src/test/Test-Report-001-12-1-2016.PNG}{which is also linked here}.

\section{Changes Due to Testing}
During the testing phase the functional requirements passed the tests and no changes were required. However, user feedback from the survey employed in the DJS showed that the UI was too minimal and looked more like a prototype then a polished product. The solution was to use Bootstrap and display more information to the user such as album art and total votes for that particular song. After the update the user surveys indicated that the appearance and usability has increased and now looked like a finished product.

\section{Automated Testing}

Automated Testing was done through a combination of Mocha.JS (for unit testing) and Selenium-Webdriver (for system-wide testing). \\


Mocha.JS tested various pure functions throughout the codebase, based on a predefined set of input and output test vectors. \\

Selenium-Webdriver was used to produce a firefox instance, simulate a connection to the server, simulate user interaction, and analyze the HTML output to ensure the server is producing the correct data, and that the web client is receiving and parsing the data correctly.
        
\subsection{Specific System Tests}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Reads songs from music folder}}\\
\hline
\textbf{Initial State: } & Library module called to read songs from a folder\\
\textbf{Input: } & Folder with songs\\
\textbf{Output: } & List of all the songs in the folder\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Reads metadata from a song}}\\
\hline
\textbf{Initial State: } & Metadata module called to read the metadata from a music file\\
\textbf{Input: } & Music file\\
\textbf{Output: } & Correct metadata information extracted from file\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Voting System returns highest voted item}}\\
\hline
\textbf{Initial State: } & Multiple users cast their votes, voter module is called\\
\textbf{Input: } & List of votes\\
\textbf{Output: } & Returns highest rated item\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Voting System handles an empty songs array}}\\
\hline
\textbf{Initial State: } & Voter module is called\\
\textbf{Input: } & Empty array of songs, non-empty array of votes\\
\textbf{Output: } & Returns empty string\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Voting System handles an empty votes array}}\\
\hline
\textbf{Initial State: } & Voter module is called\\
\textbf{Input: } & Empty array of votes, non-empty array of songs\\
\textbf{Output: } & Returns empty string\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Webpage Title is Loaded}}\\
\hline
\textbf{Initial State: } & Server is running, browser directed to webpage\\
\textbf{Input: } & N/A\\
\textbf{Output: } & Correct title of browser window is displayed\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Loads the first button}}\\
\hline
\textbf{Initial State: } & Server is running, browser directed to webpage\\
\textbf{Input: } & N/A\\
\textbf{Output: } & First button has the correct name\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Loads the second button}}\\
\hline
\textbf{Initial State: } & Server is running, browser directed to webpage\\
\textbf{Input: } & N/A\\
\textbf{Output: } & Second button has the correct name\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Loads the third button}}\\
\hline
\textbf{Initial State: } & Server is running, browser directed to webpage\\
\textbf{Input: } & N/A\\
\textbf{Output: } & Third button has the correct name\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Initially sets first vote to zero}}\\
\hline
\textbf{Initial State: } & Server is running, browser directed to webpage\\
\textbf{Input: } & N/A\\
\textbf{Output: } & First vote-count element has a value of 0\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Initially sets second vote to zero}}\\
\hline
\textbf{Initial State: } & Server is running, browser directed to webpage\\
\textbf{Input: } & N/A\\
\textbf{Output: } & Second vote-count element has a value of 0\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Initially sets third vote to zero}}\\
\hline
\textbf{Initial State: } & Server is running, browser directed to webpage\\
\textbf{Input: } & N/A\\
\textbf{Output: } & Third vote-count element has a value of 0\\
\hline
\end{tabularx}
\end{table}
\end{center}


\begin{center}
\begin{table}[H]
\begin{tabularx}{\textwidth}{| c X |}
\hline
\multicolumn{2}{|c|}{\textbf{Votes for an item when a user clicks a button}}\\
\hline
\textbf{Initial State: } & Server is running, browser directed to webpage, a vote button is clicked\\
\textbf{Input: } & N/A\\
\textbf{Output: } & Vote count for the corresponding button has a value of 1\\
\hline
\end{tabularx}
\end{table}
\end{center}

\section{Trace to Requirements}
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
Wasaddast & sadadup & BOadasdasdai & yeasadsad \\
\hline
\end{tabular}
\end{center}
\section{Trace to Modules}		

\section{Code Coverage Metrics}
\indent \indent Reviewing the test requirements matrix, test-module trace, and module-requirements the functional and nonfunctional requirements were satisfied in regards to the test cases that were created. Complete code coverage was acquired with our unit and automated testing. In addition, majority of our testing was done synchronously since many problems arose from concurrent process.  
\bibliographystyle{plainnat}

\bibliography{SRS}

\end{document}
